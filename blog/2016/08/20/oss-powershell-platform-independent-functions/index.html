<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta name=description content><meta name=keywords content><meta name=generator content="Hugo 0.53"><title>OSS PowerShell: Platform Independent Functions |</title><meta name=description content="OSS PowerShell: Platform Independent Functions - %!s(&lt;nil&gt;)"><meta itemprop=name content="OSS PowerShell: Platform Independent Functions"><meta itemprop=description content="OSS PowerShell: Platform Independent Functions - %!s(&lt;nil&gt;)"><meta property=og:title content="OSS PowerShell: Platform Independent Functions"><meta property=og:description content="OSS PowerShell: Platform Independent Functions - %!s(&lt;nil&gt;)"><meta property=og:image content="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?size=200"><meta property=og:url content=https://zacharyloeber.com/blog/2016/08/20/oss-powershell-platform-independent-functions/><meta property=og:site_name content><meta property=og:type content=article><link rel=icon type=image/png href=https://zacharyloeber.com/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://zacharyloeber.com/favicon-16x16.png sizes=16x16><link rel=stylesheet href=/sass/combined.min.5aca3dc995ccd40fd537c60ccb5ce5882145ec5d4c4827c15f277667981cc0de.css></head><body class=bilberry-hugo-theme><nav><div class=container><ul class=topnav><li><a href=https://github.com/zloeber target=_blank>Github</a></li><li><a href=/page/about/>About</a></li><li><a href=/page/about-me/>About Me</a></li></ul></div></nav><header><div class=container><div class=logo><a href=/ class=logo><img src="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mm&size=200" alt>
<span class=overlay><i class="fa fa-home"></i></span></a></div><div class=titles><h3 class=title><a href=/>My cool new blog</a></h3></div><div class=toggler><i class="fa fa-bars" aria-hidden=true></i></div></div></header><div class="main container"><div class="article-wrapper u-cf single"><a class=bubble href=/blog/2016/08/20/oss-powershell-platform-independent-functions/><i class="fa fa-fw fa-pencil"></i></a><article class="default article"><div class=content><h3><a href=/blog/2016/08/20/oss-powershell-platform-independent-functions/>OSS PowerShell: Platform Independent Functions</a></h3><div class=meta><span class="date moment">2016-08-21</span>
<span class=categories><a href=/categories/linux>Linux</a>
<a href=/categories/microsoft>Microsoft</a>
<a href=/categories/ossposh>OSSPosh</a>
<a href=/categories/powershell>Powershell</a></span>
<span class=author><a href=/author/zachary-loeber>Zachary Loeber</a></span></div><p>Just the other day Microsoft released PowerShell as open source with builds available for Windows, Mac OSX, and a few flavors of Linux. I’m pretty certain the entire community is super hyped at the news. I know I am!</p><p>I was able to quickly get PowerShell running on my Mint 17.3 (Rosa) workstation (Based on Ubuntu 14.04) in about 2 minutes flat <a href=https://github.com/powershell/powershell>using the included documentation</a>. From here I was able to start up the shell and start using all the basic commands I’ve been using for years. But I soon realized that a large portion of my code would be useless on a Linux platform. The differences between Linux and Windows are pronounced enough that I can immediately list out some code that will cause compatibility issues. This includes:</p><ul><li>Anything that references statically defined paths (think drive letters and such which do not exist on Linux)</li><li>Anything which relies on external DLLs</li><li>Anything which relies on WMI (generally is only on Windows and only targets Windows specific implementations of CIM/WBEM)</li><li>Most anything which uses Add-Type or other .NET type definitions. You will need to ensure compatibility with the .Net Core namespaces. There are <a href=https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/support-dotnet-core-instructions.md>some tools for doing this</a> for more hardcore developers. You may have some luck by searching <a href=http://packagesearch.azurewebsites.net/>here</a> for parts of your type definitions to see if it is available in .Net Core yet.</li><li>Pretty much anything &#8216;Windows-centric&#8217;. An example would be get-service. Yes, Linux and OSX has the concept of services/daemons but these are not the same as Windows services so Get-Service doesn’t work. I expect soon there will be wrapper functions available for SystemD (systemctl) and other service management frameworks but currently many of the native windows commands simply don’t work.</li></ul><h2 id=cross-platform-functions>Cross-Platform Functions</h2><p>So how would you make a cross-platform capable function? That is a great question which you can gleam a bit of insight from simply by looking at the whopper of a <a href=https://github.com/PowerShell/PowerShell/blob/master/build.psm1>build script module included with OSSPosh</a> (my newly coined term for the project). Here is the first part of the module:</p><pre class="lang:powershell decode:true"># Use the .NET Core APIs to determine the current platform; if a runtime
# exception is thrown, we are on FullCLR, not .NET Core.
try {
    $Runtime = [System.Runtime.InteropServices.RuntimeInformation]
    $OSPlatform = [System.Runtime.InteropServices.OSPlatform]

    $IsCoreCLR = $true
    $IsLinux = $Runtime::IsOSPlatform($OSPlatform::Linux)
    $IsOSX = $Runtime::IsOSPlatform($OSPlatform::OSX)
    $IsWindows = $Runtime::IsOSPlatform($OSPlatform::Windows)
} catch {
    # If these are already set, then they're read-only and we're done
    try {
        $IsCoreCLR = $false
        $IsLinux = $false
        $IsOSX = $false
        $IsWindows = $true
    }
    catch { }
}

if ($IsLinux) {
    $LinuxInfo = Get-Content /etc/os-release | ConvertFrom-StringData

    $IsUbuntu = $LinuxInfo.ID -match 'ubuntu'
    $IsUbuntu14 = $IsUbuntu -and $LinuxInfo.VERSION_ID -match '14.04'
    $IsUbuntu16 = $IsUbuntu -and $LinuxInfo.VERSION_ID -match '16.04'
    $IsCentOS = $LinuxInfo.ID -match 'centos' -and $LinuxInfo.VERSION_ID -match '7'
}</pre><p>That looks pretty easy to use, so lets go ahead and do so! Here is a quick function to get things started. This function will let you know what platform you are running on.</p><pre class="lang:powershell decode:true">function Get-OSPlatform {
    # Parameter help description
    param(
        [Parameter()]
        [Switch]$IncludeLinuxDetails
    )
    try {
        $Runtime = [System.Runtime.InteropServices.RuntimeInformation]
        $OSPlatform = [System.Runtime.InteropServices.OSPlatform]

        $IsCoreCLR = $true
        $IsLinux = $Runtime::IsOSPlatform($OSPlatform::Linux)
        $IsOSX = $Runtime::IsOSPlatform($OSPlatform::OSX)
        $IsWindows = $Runtime::IsOSPlatform($OSPlatform::Windows)
    } 
    catch {
        # If these are already set, then they're read-only and we're done
        try {
            $IsCoreCLR = $false
            $IsLinux = $false
            $IsOSX = $false
            $IsWindows = $true
        }
        catch { }
    }

    if ($IsLinux) {
        if ($IncludeLinuxDetails) {
            $LinuxInfo = Get-Content /etc/os-release | ConvertFrom-StringData
            $IsUbuntu = $LinuxInfo.ID -match 'ubuntu'
            if ($IsUbuntu -and $LinuxInfo.VERSION_ID -match '14.04') {
                return 'Ubuntu 14.04'
            }
            if ($IsUbuntu -and $LinuxInfo.VERSION_ID -match '16.04') {
                return 'Ubuntu 16.04'
            }
            if ($LinuxInfo.ID -match 'centos' -and $LinuxInfo.VERSION_ID -match '7') {
                return 'CentOS'
            }
        }
        return 'Linux'
    }
    elseif ($IsOSX) {
        return 'OSX'
    }
    elseif ($IsWindows) {
        return 'Windows'
    }
    else {
        return 'Unknown'
    }
}</pre><p>Here is how you might use the above function to write a generic function for getting the current IP address of the system you are on.</p><pre class="lang:powershell decode:true">function Get-PIIPAddress {
    switch ( Get-OSPlatform ) {
        'Linux' {
            $ipaddress = @([System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces() | Where {($_.OperationalStatus -eq 'Up')})
            ($ipaddress[0].Addresses | Where {$_.AddressFamily -eq 'InterNetwork'}).IPAddressToString
        }
        'OSX' {}
        Default {
            @(Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.DefaultIpGateway})[0].IPAddress[0]
        }
    } 
}</pre><p>This is kind of a silly example but should get the point across. I&#8217;m essentially using two different methods to get the same information (a great improvement exercise for the reader would be to use the GetAllNetworkInterfaces first then filter based on name or something based on the platform and eliminate the Get-WMIObject entirely).</p><h2 id=some-other-notes>Some Other Notes</h2><p>If you want a quick Linux box of your own to try things out on here are my fast setup commands using vagrant with virtualbox (BTW, if you don&#8217;t already use chocolatey you can use this excellent app to get these two programs installed in record time on your workstation).</p><pre class="lang:powershell decode:true">mkdir C:\Vagrant
mkdir C:\Vagrant\Ubuntu
cd C:\Vagrant\Ubuntu
vagrant init ubuntu/xenial64
vagrant up
vagrant ssh

wget https://github.com/PowerShell/PowerShell/releases/download/v6.0.0-alpha.9/powershell_6.0.0-alpha.9-1ubuntu1.16.04.1_amd64.deb
sudo apt-get install libunwind8 libicu55
sudo dpkg -i powershell_6.0.0-alpha.9-1ubuntu1.16.04.1_amd64.deb</pre><p>I went ahead and installed OSSPosh (Or just PowerShell 6 if you prefer?) on my Windows 10 workstation as well. This installed quickly and without interfering with my current PowerShell profile or paths. You can quickly tell if you are in the Core or Desktop edition by taking a peek at the $PSEdition variable.</p><p>Interestingly enough the Powershell profile path is different. The desktop edition of Powershell (5.0) points where you would expect it to:</p><pre class="lang:powershell decode:true">C:\Users\zloeber\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</pre><p>In the core version of PowerShell it points to a more platform agnostic path:</p><pre class="lang:powershell decode:true">C:\Users\zloeber\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</pre><p>What I&#8217;m still trying to figure out is why the core edition loads different modules on my workstation than on my Linux box. There is a difference somewhere that I&#8217;ve yet to isolate but I&#8217;m sure will become clear soon enough.</p><h2 id=a-bug-update>A Bug? (Update)</h2><p>I&#8217;ve noticed a bug when using some native Linux commands from a Powershell console when connected to the host via SSH. It seems to hang the shell (or cause it to act sporadic and delayed). Currently aliases for ls, ps, and others are not set as the Posh team figures out the best way to go with this one. Simply setting some of these in the profile before loading the console seems to avert the issue for now. After connecting to your host via ssh do the following to create a profile script</p><pre class="lang:powershell decode:true">mkdir ~/.config/powershell/
nano ~/.config/powershell/Microsoft.PowerShell_profile.ps1</pre><p>Then add in a few aliases like so:</p><pre class="lang:powershell decode:true">New-Alias -Name ls -Value 'Get-ChildItem'
New-Alias -Name ps -Value 'Get-Process'
</pre><p>I&#8217;d use a tool like screen or tmux before loading the shell so you can kill it if things go wonky on you for whatever reason.</p><h2 id=final-thoughts>Final Thoughts</h2><p>I’m sure there are cleverer ways to get things like this done and I expect them to emerge in the coming months. Until then you may want to start thinking of modules you have written and seeing if they are good candidates for becoming cross-platform. This is exciting times for us cross-platform geeks. We are getting bash on Windows, Powershell on Linux, what next? I don’t know but I’m looking forward to seeing where things go!</p></div><div class=footer><div class=tags><i class="fa fa-tags"></i><div class=links><a href=/tags/linux>Linux</a>
<a href=/tags/oss>OSS</a>
<a href=/tags/ossposh>OSSPosh</a>
<a href=/tags/powershell>Powershell</a>
<a href=/tags/powershell-script>Powershell Script</a>
<a href=/tags/scripting>Scripting</a>
<a href=/tags/windows>Windows</a></div></div></div></article></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"zacharyloeber-com"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><footer><div class=container><div class=recent-posts><strong>Latest posts</strong><ul><li><a href=/blog/2018/12/10/devops-tool-of-the-day-syncthing/>Devops: Tool of the day – Syncthing</a></li><li><a href=/blog/2018/09/28/devops-automating-kubernetes-deployments/>DevOps – Automating Kubernetes Deployments</a></li><li><a href=/blog/2018/05/02/powershell-to-python-notes-from-the-field/>Powershell To Python Notes From The Field</a></li><li><a href=/blog/2018/03/26/powershell-windows-subsystem-for-linux/>PowerShell: Windows Subsystem For Linux</a></li><li><a href=/blog/2018/02/24/email-reputation-and-design-a-condensed-guide/>Email Reputation and Design: A Condensed Guide</a></li><li><a href=/blog/2018/02/04/powershell-azuread-dynamic-groups/>PowerShell: AzureAD Dynamic Groups</a></li><li><a href=/blog/2018/01/10/powershell-office-365-group-based-licencing-cleanup/>PowerShell: Office 365 Group Based Licencing Cleanup</a></li></ul></div><div class=categories><a href=/categories/><strong>Categories</strong></a><ul><li><a href=/categories/system-administration>System administration (130)</a></li><li><a href=/categories/microsoft>Microsoft (120)</a></li><li><a href=/categories/powershell>Powershell (106)</a></li><li><a href=/categories/networking>Networking (52)</a></li><li><a href=/categories/active-directory>Active directory (44)</a></li><li><a href=/categories/exchange>Exchange (38)</a></li><li><a href=/categories/exchange-2010>Exchange 2010 (38)</a></li></ul></div><div class=right><div class=external-profiles><strong>Social media</strong></div></div></div></footer><div class=credits><div class=container><div class=copyright><a href=https://github.com/Lednerb target=_blank>&copy;
2018
by Lednerb</a></div><div class=author><a href=https://github.com/Lednerb/bilberry-hugo-theme target=_blank>Bilberry Hugo Theme</a></div></div></div><script type=text/javascript src=/js/externalDependencies.39c47e10e241eae2947b3fe21809c572.js integrity="md5-OcR&#43;EOJB6uKUez/iGAnFcg=="></script><script type=text/javascript src=/js/theme.ff50ae6dc1bfc220b23bf69dbb41b54e.js integrity="md5-/1CubcG/wiCyO/adu0G1Tg=="></script><script>$(".moment").each(function(){$(this).text(moment($(this).text()).locale("en").format('LL'));});$(".footnote-return sup").html("");</script></body></html>